### 操作系统内核

CPU为什么要引入内核模式？是为了保护内核。例如，页表本身是一定要保护起来不让应用程序访问的，否则一个应用程序就可以通过修改页表访问任意的物理内存，破坏了内存地址空间的隔离性。前面说到，页表项中有U/S位，这个位什么时候检查？是在CPU访问该地址的时候检查：CPU内部也有一个U/S位，表示当前CPU运行的状态，表示运行在内核态还是用户态，这个位和页表的位必须满足检查的条件，否则CPU就会报exception。

**OS内核的地址空间**

既然引入了内核，那么内核是否应当与应用程序一样，占用单独的一个地址空间呢？这是一种可行的设计。但问题是每次应用程序调用system call时，都需要进行一次地址空间的切换，导致性能比较差。另一种设计是让内核与应用程序共享一个地址空间，内部用分区的方式隔离（前文提过分区的方式），这样当做system call时，不需要切换地址空间，唯一的切换就是CPU内部U/S位的切换，开销小很多。这种设计是否意味着每个应用都有一个内核？并不是，因为内核会通过虚拟内存机制把唯一的自己映射到所有应用的虚拟地址空间，所以物理上只有一份内核的代码和数据。

内核虽然和应用共享一个地址空间，但其上下文却完全不同。内核的上下文包括哪些？和应用一样，都是寄存器和内存，其中最重要的是PC和栈。内核的栈与应用程序是不同的，否则如果内核复用应用的栈，那么想象一下有一个多线程的应用运行在多核上，其中一个CPU核-A在执行系统调用，另一个CPU核-B在用户态，那么core-B就可以看到甚至修改core-A的栈，从而改变内核代码的执行，这是很危险的。内核为每个应用都有提供了一个内核栈，这个栈一般比较小，因为内核中基本没有递归，所以不用很大的栈。Linux中则是将栈直接和thread-info（每个线程对应的数据结构）放在了一起，一旦栈溢出了也只会影响当前的thread（小概率影响整个内核）。

**内核与用户态应用的切换**

内核与用户态的切换通过特定指令完成。从用户态进入内核有几种情况：硬件中断，软件异常。其中，软件异常包括int指令，例如通过int 0x80主动触发一个trap。从内核回到用户态通常通过iret完成。在下学期的OS课我们会介绍更多这方面的指令，例如syscall和sysreturn，以及sysenter和sysexit，这些新的指令有更高的性能，但原理都是类似的。在现代系统中，基本都是用sysenter和sysexit来完成。从程序员的角度，一般不用直接调上述指令，而是调libc提供的库函数，这些库函数可以认为是对系统调用的封装，目的是为了简化处理和跨平台（不同OS）。

具体来说，从用户态进入内核时，CPU会将当前的寄存器都保存到内核的栈中，在执行iret指令时CPU会从栈中pop并恢复这些寄存器。这些寄存器记录了应用的运行上下文，包括了PC、EBP、ESP等，所以恢复之后应用就会从之前被中断的PC往下继续执行。应用程序每次进入内核，第一条指令都是相同的，然后会根据系统调用的不同序号dispatch到不同的函数进行处理；回到应用也是相同的代码，所以可以认为，在执行系统调用的时候，内核并不需要保存运行的上下文（注意：如果内核运行时来了硬件interrupt则还是需要保存上下文）。

操作系统是否有可能反过来调用应用程序的函数呢？Signal的处理可以看做这一类。回顾一下signal的几个函数：应用程序首先要注册一个signal和sigaction的绑定，在sigaction中制定一个signal handler。这样，当另一个进程通过操作系统发送signal时，操作系统就会调用相应的signal handler。那么，操作系统到底是如何“调用”的呢？这里调用有引号，是因为操作系统不可能直接通过call指令去执行handler，因为handler必须在用户态运行，所以一定有一个iret（或systexit）。但刚才说到，iret的时候用户态的PC会被恢复成进内核之前的PC值，而不是handler的地址。因此一个简单的方法，就是把栈上保存的用户态PC的值设置为handler的地址，这样当运行iret的时候就会去运行handler了。

新的问题就来了：当handler返回的时候会发生什么呢？我们知道返回操作就是pop stack中保存的return address然后跳过去执行，考虑这个场景：如果之前是foo()调用了bar()函数，bar()执行到一半的时候做system call进入内核，此时恰好收到了一个signal，于是内核在iret的时候直接跳到了handler()，那么handler()返回时，会跳回到foo()，但此时bar()还没执行完！所以此时返回到foo()一定是错误的。一种解决办法，就是修改一下用户态的栈，插入一个新的return address，就是之前bar()被中断时的PC值，这样当handler()返回时，就会跳到bar()被中断的地方往下继续执行，问题解决了。

但我们看Linux实现时，发现Linux采用了这样的流程：在栈上插入了一个新的系统调用sigreturn()的地址，而不是bar()被中断的地址。这个sigreturn()是每个进程都会有的一个函数，是loader在加载应用二进制时就默认加载到代码段的，起作用是回到内核。然后内核会重新修改内核栈上保存的用户态PC值，改为bar()被中断的地址，然后iret回到bar()继续执行。为什么要这么做呢？这样不是多了一次系统调用么？原因是在处理完signal后内核还要做一些善后的工作。在ICS中我们学过，当处理signal时，操作系统会将同样的signal暂时屏蔽掉（mask），防止同一个signal handler出现嵌套的情况（想一想这会导致什么问题）。所以，当handler()返回后，操作系统需要去掉屏蔽，也就是把signal mask上对应的位清零，这就是sigreturn这个系统调用要做的事情之一。


